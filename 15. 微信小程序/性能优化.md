# 1. 微信小程序性能优化

## 1.1. 加载流程

当你打开一个小程序的时候就会经历这三个过程：

1. 资源准备，小程序在下载你的代码包
2. 业务代码注入和渲染，小程序将你的业务代码分别注入视图层和逻辑层，并在视图层做视图的渲染
3. 异步数据的请求，显示加载中的时候，其实就是在到达首页时，如果首页有异步数据请求，这个时候小程序就会执行异步数据请求

## 1.2. 启动性能优化

### 1.2.1. 代码包大小

代码包大小会直接影响小程序的启动速度，代码包越大，小程序的启动时间就越长，在小程序启动时，下载代码包和代码注入的时间和小程序代码包大小是成正比的，一般小程序的平均启动时间是 2s 左右，可以看看你的小程序有没有拖后腿，那么如何控制包大小呢？

### 1.2.2. 资源控制

1. 开启开发工具”上传代码时自动压缩”，小程序开发工具有一个上传代码时自动压缩的功能，当开启时，会在你上传代码时为你做代码压缩，除了这个，我们也可以通过使用第三方打包工具做代码压缩，如 webpack、grunt、grulp。
2. 及时清理无用代码和资源文件，无用的代码和资源也会占用一定的包大小。
3. 减少代码包中的资源文件，将资源存放在 cdn 上，小程序开发工具对资源文件的压缩比率非常低，资源有条件的可以尽量放在 CDN 上，因为小程序开发工具对资源文件的压缩比率非常低，只有 10%左右，或者也可以用第三编译工具对资源文件自己进行压缩处理

### 1.2.3. 分包加载

将小程序中不常用的代码放在分包中，主包内只保留用户最常访问的页面，但是由于官方规定 tab 页面只能放在主包中，因为小程序启动时只会加载主包，使用时按需下载分包，不会在加载时一次将整个代码包下载，这样就能有效减少启动加载的时间。
但是分包加载也有它的局限性，用户首次打开分包页面时，需要先进行分包代码的加载和注入，会造成页面切换时产生一定的延时，因此在此基础上，官方又推出了分包预加载和独立分包。

#### 1.2.3.1. 分包预加载

分包加载时的流程：

打开首页 —— 跳转分包页面 —— 下载分包 —— 注入分包 —— 打开页面

**分包预下载**：提前配置可能会跳到哪些分包，框架在进入页面后根据配置进行预下载，分包预加载会在你进入主包页面后，为你静默开启分包代码的下载和注入，这个过程是无感的

分包预加载需要注意的是：同一个分包中的页面享有共同的预下载大小限额 2M，限额会在工具中打包时校验，因此不能把所有的分包页面都配置到分包预加载的配置中，只配置主包页面会跳转的页面即可。

#### 1.2.3.2. 独立分包

由于从分包页面启动是，必须要依赖于主包的下载和注入，启动速度会受到主包大小的制约，因此这就有了独立分包，独立分包在启动分包页面时，可以独立启动而不需要依赖主包，这样就可以减少主包下载和注入的时间，通常情况下我们会将活动、广告一类的具有独立逻辑的功能代码标记为一个独立分包，在分包页面启动时，可以不依赖于主包启动，只下载分包代码进行注入。

### 1.2.4. 首屏加载性能优化

1. 提前请求：异步数据数据请求不需要等待页面渲染完成
2. 利用缓存：利用 storage API 对异步请求数据进行缓存，二次启动时先利用缓存数据渲染页面，再进行后台更新
3. 避免白屏：先展示页面骨架和基础内容
4. 及时反馈：及时地对需要用户等待的交互操作给出反馈，避免用户以为小程序没有响应

### 1.2.5. 渲染性能优化

js 引擎和 native 都可以过 js 的计算或者 data 修改来对 Webview 发起绘制操作，但是对开发者来说最重要的就是 js 引擎和 Webview 之间的通信，这通信过程是一个跨进程通信，是非常耗时的一个过程，我们要提高渲染的性能，也就是减少这个跨进程通信的时间。

#### 1.2.5.1. 避免不当使用 setData

1. 使用 data 在方法间共享数据，会增加 setData 传输的数据量，同时会增加页面重绘的概率
2. data 仅包括与页面相关的数据
3. 使用 setData 传输大量数据，通讯耗时与数据量正相关，页面更新延迟可能造成更新开销增加
4. 仅传输页面中发生变化的数据，使用 setData 的特殊 key 实现局部更新
5. 后台页面进行 setData 抢占前台页面的资源
6. 页面切入后台后的 setData 调用，延迟到页面重新展示的时候执行

#### 1.2.5.2. 避免不当使用 onPageScroll

1. 只在必要的时候监听 pageScroll 事件
2. 避免在 onPageScroll 中执行复杂逻辑
3. 避免在 onPageSroll 中频繁调用 setData
4. 避免频繁查询节点信息(SelectQuery),部分场景使用节点布局相交状态监听(IntersectionObserver)替代
