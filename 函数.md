# 1. 函数

## 1.1. 函数定义

一堆特定代码的集合体，它负责完成某项特定任务，而且相较于其他代码，具备相对的独立性，一般会有输入参数并有返回值，提供对过程的封装和细节的隐藏。

函数就是一个功能，并且具备复用性。

声明函数和使用函数

```JavaScript
// 声明函数式函数
    function func() {
        alert("hello,world");
    }

//函数构造函数（匿名函数）
    var func = new Function(alert("hello,world"));

//函数直接量（函数表达式）
    var func = function () {
        alert("hello,world");

// 调用函数
functionName();
```

特点说明：

- 函数默认不会执行，必须通过函数名()调用才会执行；
- 函数的命名尽量遵守，以驼峰式动词或者动词+名词的方式，这样函数的作用一目了然；
- 函数一次声明可以多次调用，每一次函数调用函数体会重新执行一次。

## 1.2. 函数传参

JavaScript 中所有函数的参数都是按值传递的，也就是说把函数外部的值赋给内部的参数，就如同把一个变量赋值给另一个变量一样。

形式参数：在声明函数的小括号里的数值，形参的作用就是声明变量

实际参数：在调用函数的小括号里写的数值，实参的作用就是给形参赋值。

在 JavaScript 中，实参的个数和形参的个数可以不一样，如果实参过多那么多余的实参会被忽略，如果形参过多则会自动填上 undefined。

### 1.2.1. 基本类型值传递

定义一个处理函数，传递给函数一个数值类型的值，只会修改局部变量的值，而不会修改外部变量。

```JavaScript
//创建一个函数，在函数内部更改基本类型参数的值
function add(num) {
    return num + 10;
}
var count = 10;
add(count);//20
count;//10
```

在函数 add()内部更改基本类型 count(num=count)的值，没有反映到函数外部的基本类型变量 count。说明基本类型是按值传递参数的。

### 1.2.2. 引用类型值传递

对象传递的是**地址**, 函数内外的变量会根据引用访问同一个对象, 因为堆中对应的地址只有一个。

```JavaScript
function handleObj(obj) {
    obj.name = 'jack';
    console.log('FNobj:'+JSON.stringify(obj.name)); // jack
}
var parson = new Object();
handleObj(parson);
console.log('parson:'+JSON.stringify(parson.name)); // jack
```

## 1.3. 函数的返回值

当函数程序运行后的结果外部需要使用的时候，我们不能直接给与，需要通过 return 返回。
函数内部，return 后面的值就是返回值，将函数执行后剩下的结果返回给主调

JavaScript 中函数返回值的特点如下：

1. 如果函数没有显示的使用 return 语句 ，那么函数有默认的返回值：undefined；
2. 如果函数使用 return 语句，那么跟再 return 后面的值，就成了函数的返回值；
3. 如果函数使用 return 语句，但是 return 后面没有任何值，那么函数的返回值也是：undefined；
4. 函数使用 return 语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说 return 后面的所有其他代码都不会再执行,所以函数返回至具有切断函数执行的功能。

## 1.4. 函数没有重载

```JavaScript
    function addSomeNumber(num){
        return num + 100;
    }

    function addSomeNumber(num){
        return num + 200;
    }

    var result = addSomeNumber(100);//300
```

显然这个例子中声明了两个同名函数，而结果则是后面的函数覆盖了前面的函数。

以上代码实际上与下面的代码没有什么区别。

```JavaScript
    var addSomeNumber = function(num){
        return num + 100;
    };

    addSomeNumber = function(num){
        return num + 200;
    };

    var result = addSomeNumber(100);//300
```

通过观察重写之后的代码，很容易看清楚到底是什么一回事——在创建第二个函数时，实际上覆盖了引用第一个函数的变量 addSomeNumber。
