# 闭包

## 闭包的引入

闭包是和作用域相关的

1. 在函数外面访问函数内部 num 的值

   ```JavaScript
   function fn(){
     var num = 10;
     return num;
   }

   var ret = fn();

   console.log(ret);//10
   ```

2. 在函数内部去访问 num 的值

   ```JavaScript
   function fn(){
   var num = 10;
     function inner(){
       // 函数的作用域在定义的时候就确定下来了
       console.log(num);//10
     }

     inner();
   }

   fn();
   ```

3. 在函数在内部去修改 num 的值

   ```JavaScript
   function fn(){
     var num = 10;

     function inner(n){
       num = n;
       console.log(num);//100
     }

     inner(100);
   }
   fn();
   ```

4. 函数外部去修改函数内部 num 的值

   ```JavaScript
   function fn(){
     var num = 10;
     function inner(n){
       num = n;
       console.log(num);//1000
     }
     return inner;
   }
   var res =fn();
   res(1000);
   ```

## 闭包的概念

闭包（closure）：闭包是函数和声明该函数的词法环境的组合。
函数：内部函数
声明该函数：外部函数
词法环境：作用域（作用域链）
组合：以上的综合（整体）
形成闭包的条件：有两个函数，嵌套关系，内部函数还访问了外部函数的变量。

## 闭包的作用

1. 私有化变量，保护数据的安全
2. 持久化维持数据

## 闭包存在的问题

闭包占用的内存是不会被释放的，因此，如果滥用闭包，会造成内存泄漏的问题。闭包很强大，但是只有在必须使用闭包的时候才使用。

### js 的垃圾回收机制

内存：计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大，运行程序需要消耗内存，当程序结束时，内存会得到释放。

javascript 分配内存：当我们定义变量，javascript 需要分配内存存储数据。无论是值类型或者是引用类型，都需要存储在内存中。

垃圾回收：当代码执行结束，分配的内存已经不需要了，这时候需要将内存进行回收，在 javascript 语言中，垃圾回收机制会帮我们回收不再需要使用的内存。

### 标记清除法

JavaScript 中最常用的收集方式就是**标记清除**。当变量进入环境时，就将这个变量标记为“进入环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

从 2012 年起，所有现代浏览器都使用了标记-清除垃圾回收算法。

```JavaScript
var a = {
  name: "cocytus"
}
a = null;

// 当闭包的功能完成之后（闭包的功能不在需要的时候），需要手动释放掉闭包占用的内存
ret = null; // 这样垃圾回收机制会回收闭包占用的内存
```

### 引用计数法

另外一种不太常见的垃圾收集方法叫做**引用计数**。

我们先创建一个对象，这时 js 已经完成了内存分配，将对象的地址赋值给了变量 o，那么这个对象被 o 引用了，给对象计数，引用计数为 1。

```JavaScript
var o = {
  name: "cocytus"
}
```

然后我们把对象的地址赋值给了 o2，o2 也引用了这个对象，对象引用计数为 2

```JavaScript
var o2 = o;
```

引用计数存在的问题：循环引用，对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含了一个指向对象 A 的引用。

```JavaScript
function fn(){
  var obj1 = {}; // 对象被引用了两次
  var obj2 = {}; // 对象被引用了两次

  obj1.a = obj2;
  obj2.b = obj1;
}
```

obj1 和 obj2 通过各自的属性相互引用，也就是说这两个对象的引用次数都是 2。这样每调用一次 fn 函数，在内存里面就会创建两个对象，fn 调用结束后，这两个对象被垃圾回收机制回收不了，因为这两个对象不是 0 引用的对象

当多次调用 fn 函数，就会多次创建两个对象，造成内存泄漏问题。

```JavaScript
fn();
fn();
fn();
fn();
fn();
```

为了避免类似这样的循环引用问题。最好是在不适用它们的时候手工断开原生 JavaScript 对象与 DOM 元素之间的连接。

```JavaScript
obj1 = null;
obj2 = null;
```

将变量设置为 null 意味着切断变量与它此前引用的值之前的连接。当垃圾收集器下次运行时，就会删除这些值并回收它们占用的内存。
